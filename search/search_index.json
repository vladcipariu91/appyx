{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Appyx","text":"<p>Model-driven navigation for Jetpack Compose</p> <p>https://github.com/bumble-tech/appyx</p>"},{"location":"#navigation-for-your-compose-app-on-steroids","title":"Navigation for your Compose app on steroids","text":"<ul> <li>Navigate directly from code \u2013 In a type-safe way, without boilerplate</li> <li>Gain control of navigation state \u2013 Making your navigation unit-testable</li> <li>Complete control over operations and behaviour \u2013 Use and extend the back stack or the view pager from the library, or build your own </li> <li>Your own navigation \u2013 With Appyx, you can define your own navigation models</li> <li>Use any animation for transitions \u2013 Anything you can represent with Compose <code>Modifiers</code></li> </ul>"},{"location":"#model-driven-navigation-a-different-paradigm-with-superpowers","title":"Model-driven navigation \u2013 a different paradigm with superpowers","text":"<p>Using Appyx you gain navigation superpowers in addition to screen-to-screen navigation:  </p> <ul> <li>Break down screen boundaries \u2013 Using <code>NavModels</code> you can navigate inside the screen as well as between them</li> <li>Make your navigation composable \u2013 Navigate whole scopes of your application </li> </ul> <p>Using a model-driven approach, navigation states are yours to define \u2013 Appyx makes it happen with any animation you can represent using Compose <code>Modifiers</code>. Back stacks, card stacks, view pagers are just the beginning:</p> <p> </p> <p>You can create custom navigable components in no time:</p> <p></p> <p>With Appyx you can break down screen boundaries and transform the screen itself:</p> <p></p> <p>See Model-driven navigation for more details.</p>"},{"location":"#launch-the-demo-app","title":"Launch the demo app","text":"<p>Check out the project and launch the <code>:app</code> module for a quick demonstration!</p>"},{"location":"#download","title":"Download","text":"<p>See the Downloads page.</p>"},{"location":"#learning-appyx","title":"Learning Appyx","text":"<p>Check out the Quick start guide, Codelabs, and Sample apps!</p>"},{"location":"#articles","title":"Articles","text":"<ol> <li>Appyx is released! (1.0-alpha02)</li> <li>Appyx vs Jetpack Compose Navigation</li> <li>Modelling dating cards navigation with Appyx</li> </ol>"},{"location":"#videos","title":"Videos","text":"<p> Model-driven navigation with Jetpack Compose </p> <p> Model-driven navigation with Appyx</p>"},{"location":"#news-updates","title":"News &amp; updates","text":"<p>See our News &amp; updates page</p> <p>You can also follow some of us tweeting about Appyx on these accounts: </p> <ul> <li>@ZsoltKocsi</li> <li>@andreyk_nn</li> </ul>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#navigation-related","title":"Navigation-related","text":""},{"location":"faq/#q-how-does-appyx-relate-to-jetpack-compose-navigation","title":"Q: How does Appyx relate to Jetpack Compose Navigation?","text":"<p>We wrote an article on this: Appyx vs Jetpack Compose Navigation</p> <p>While Appyx represents a different paradigm, it can also co-exist with Jetpack Compose Navigation. This can be helpful if you want to use Appyx for in-screen mechanisms only, or if you plan to migrate gradually.</p> <p>See Sample apps for more details.</p>"},{"location":"faq/#q-how-does-appyx-compare-against-other-navigation-solutions","title":"Q: How does Appyx compare against other navigation solutions?","text":"<p>The core concepts of navigation in Appyx differ from most navigation libraries: </p> <ol> <li>You don't have a concept of the \"screen\" present in the model</li> <li>You can define your own navigation models</li> <li>On the UI level you can transform what feels like the \"screen\" itself</li> </ol> <p>See Model-driven navigation for more details.</p>"},{"location":"faq/#q-how-can-i-navigate-to-a-specific-part-of-my-appyx-tree","title":"Q: How can I navigate to a specific part of my Appyx tree?","text":"<p>In most cases Implicit navigation can be your primary choice, and you don't need to explicitly specify a remote point in the tree. This is helpful to avoid coupling.</p> <p>For those cases when you can't avoid it, Explicit navigation and Deep linking covers you.</p>"},{"location":"faq/#q-what-about-dialogs-bottom-sheets","title":"Q: What about dialogs &amp; bottom sheets?","text":"<p>You can use Appyx in conjunction with Accompanist or any other Compose mechanism.</p> <p>If you wish, you can model your own Modal with Appyx too. We'll add an example soon.</p>"},{"location":"faq/#q-can-i-have-a-bottom-sheet-conditionally","title":"Q: Can I have a bottom sheet conditionally?","text":"<p>You could use a similar approach as we do with back buttons in <code>SamplesContainerNode</code> you can find in the <code>:app</code> module: store a flag in the <code>NavTarget</code> that can be different per instance.</p>"},{"location":"faq/#using-appyx-in-an-app","title":"Using Appyx in an app","text":""},{"location":"faq/#q-is-it-an-all-or-nothing-approach","title":"Q: Is it an all or nothing approach?","text":"<p>No, you can adopt Appyx gradually:</p> <ul> <li>Plug it in to one screen and just utilise its screen transformation capabilities (e.g. Cards)</li> <li>Plug it in to a few screens and substitute another navigation mechanism with it, such as Jetpack Compose Navigation</li> </ul>"},{"location":"faq/#q-what-architectural-patterns-can-i-use","title":"Q: What architectural patterns can I use?","text":"<p>Appyx is agnostic of architectural patterns. You can use any architectural pattern in the <code>Nodes</code> you'd like. You can even use a different one in each.</p>"},{"location":"faq/#q-can-i-use-it-with-viewmodel","title":"Q: Can I use it with ViewModel?","text":"<p>Yes, we'll add an example soon.</p>"},{"location":"faq/#q-can-i-use-it-with-hilt","title":"Q: Can I use it with Hilt?","text":"<ul> <li>Our draft PR: #115 (Feel free to provide feedback!)</li> <li>https://github.com/jbreitfeller-sfix/appyx-playground another approach on this topic</li> </ul>"},{"location":"faq/#performance-related","title":"Performance-related","text":""},{"location":"faq/#q-are-nodes-kept-alive","title":"Q: Are <code>Nodes</code> kept alive?","text":"<p>In short: you can decide whether a <code>Node</code>:</p> <ul> <li>is on-screen</li> <li>is off-screen but kept alive</li> <li>is off-screen and becomes destroyed</li> </ul> <p>Check the Lifecycle for more details.</p>"},{"location":"faq/#on-the-project-itself","title":"On the project itself","text":""},{"location":"faq/#q-is-it-production-ready","title":"Q: Is it production ready?","text":"<p>Yes, Appyx matured to its stable version. We also use it at Bumble in production, and as such, we're committed to maintaining and improving it.</p>"},{"location":"faq/#q-whats-your-roadmap","title":"Q: What's your roadmap?","text":"<p>We're full with ideas where to take Appyx further! A more detailed roadmap will be added later. Come back for more updates.</p>"},{"location":"faq/#other","title":"Other","text":"<p>Have a question? Raise it in Discussions!.</p>"},{"location":"news/","title":"News &amp; updates","text":"<p>This section contains noteworthy updates related to the project and the project page. For a detailed list of  changes to the codebase, check Changelog.</p>"},{"location":"news/#28-nov-2022","title":"28 Nov 2022","text":"<ul> <li>Added Coding challenges</li> <li>Updated Transitions</li> </ul>"},{"location":"news/#21-nov-2022","title":"21 Nov 2022","text":"<p>FAQ received a major update</p>"},{"location":"news/#31-oct-2022","title":"31 Oct 2022","text":"<p>\ud83c\udf89 Released 1.0.0 \ud83c\udf89</p>"},{"location":"news/#27-28-oct-2022","title":"27-28 Oct 2022","text":"<p>Model-driven navigation with Appyx</p>"},{"location":"news/#22-sep-2022","title":"22 Sep 2022","text":"<p>Added documentation on ChildAware API. You can use it to scope communication with (or between) dynamically available child nodes easily.</p>"},{"location":"news/#1-2-sep-2022","title":"1-2 Sep 2022","text":"<p>Model-driven navigation with Jetpack Compose </p>"},{"location":"apps/childaware/","title":"ChildAware API","text":"<p>The framework includes the <code>ChildAware</code> interface which comes with a powerful API.</p> <p>It allows you to scope communication with (or between) dynamically available child nodes easily.</p>"},{"location":"apps/childaware/#baseline","title":"Baseline","text":"<p>In the next examples:</p> <ol> <li>Let's assume that <code>SomeNode</code> can host multiple child nodes: <code>Child1</code>, <code>Child2</code>, etc.</li> <li><code>SomeInteractor</code> belongs to <code>SomeNode</code> and is passed as a Plugin    to it</li> <li><code>SomeInteractor</code> extends the <code>Interactor</code> helper class from the framework:<ul> <li>It implements <code>NodeLifecycleAware</code>, which makes sure it will receive the <code>onCreate</code> callback   from the framework</li> <li>It implements <code>ChildAware</code>, which unlocks the DSL we'll see in the following   snippets</li> </ul> </li> </ol>"},{"location":"apps/childaware/#single-child-scenario","title":"Single child scenario","text":"<pre><code>import androidx.lifecycle.Lifecycle\nimport com.bumble.appyx.core.children.whenChildAttached\nimport com.bumble.appyx.core.children.whenChildrenAttached\nimport com.bumble.appyx.core.clienthelper.interactor.Interactor\n\n\nclass SomeInteractor : Interactor&lt;SomeNode&gt;() {\n\noverride fun onCreate(lifecycle: Lifecycle) {\nlifecycle.subscribe(onCreate = {\n\n// This lambda is executed every time a node of type Child1Node is attached:\nwhenChildAttached { commonLifecycle: Lifecycle, child1: Child1Node -&gt;\n// TODO:\n//  - establish communication with child1 \n//  - use commonLifecycle for scoping \n//  - it will be capped by the lifecycles of child1 and the parent\n}\n})\n}\n}\n</code></pre>"},{"location":"apps/childaware/#multiple-children","title":"Multiple children","text":"<pre><code>import androidx.lifecycle.Lifecycle\nimport com.bumble.appyx.core.children.whenChildAttached\nimport com.bumble.appyx.core.children.whenChildrenAttached\nimport com.bumble.appyx.core.clienthelper.interactor.Interactor\n\n\nclass SomeInteractor : Interactor&lt;SomeNode&gt;() {\n\noverride fun onCreate(lifecycle: Lifecycle) {\nlifecycle.subscribe(onCreate = {\n\n// This lambda is executed every time these two nodes are attached at the same time:\nwhenChildrenAttached { commonLifecycle: Lifecycle, child1: Child1Node, child2: Child2Node -&gt;\n// TODO\n//  - establish communication between child1 &amp; child2 \n//  - use commonLifecycle for scoping\n//  - it will be capped by the lifecycles of child1, child2 and the parent\n}\n})\n}\n}\n</code></pre>"},{"location":"apps/lifecycle/","title":"Lifecycle","text":"<p>Nodes have their own lifecycles, directly using the related classes of <code>androidx.lifecycle</code>.</p>"},{"location":"apps/lifecycle/#capping","title":"Capping","text":"<p>No node can be in a higher lifecycle state than any of its parents or the Android Activity it lives in.</p>"},{"location":"apps/lifecycle/#on-screen-off-screen","title":"On-screen &amp; off-screen","text":"<p><code>NavModel</code> controls which children should be rendered on the screen and which should not with <code>NavModel.screenState</code>. The behaviour is customisable in <code>BaseNavModel</code> via <code>OnScreenStateResolver</code>.</p> <p>When a <code>NavElement</code> of the node is marked as on-screen, its lifecycle follows the parent node's lifecycle. The rendering status does not affect it \u2013 the node might not be added to Compose view and still be in a <code>RESUMED</code> state.</p> <p>When a <code>NavElement</code> of the node is marked as off-screen, the following might happen:</p> <ul> <li>Its lifecycle is capped with <code>CREATED</code> (or <code>STOPPED</code>) in case of <code>ChildEntry.KeepMode.KEEP</code>. </li> <li>The node is destroyed and its state is saved in case of <code>ChildEntry.KeepMode.SUSPEND</code>.</li> </ul> <p><code>ChildEntry.KeepMode</code> settings can be configured for each <code>ParentNode</code> individually or globally via <code>Appyx.defaultChildKeepMode</code>.</p> <p>When a node is removed completely from <code>NavModel</code>, it will be in <code>DESTROYED</code> state.</p>"},{"location":"apps/lifecycle/#lifecycle-changes","title":"Lifecycle changes","text":"<p>The lifecycle state can be affected by:</p> <ul> <li>The NavModel of the parent (adding or removing child <code>Nodes</code> and changing their on-screen status)</li> <li>The parent's lifecycle state capping its children (transitive in the tree)</li> <li>Android lifecycle (Activity) capping the whole tree</li> </ul>"},{"location":"apps/lifecycle/#back-stack-node-lifecycle","title":"Back stack node lifecycle","text":"<p>An example demonstrating the above:</p> <p></p> <p>Note that NavModels might have their slight differences (e.g. whether their operations remove a <code>Node</code> only from the view, or completely destroy it).</p> <p>In the case of the back stack:</p> <ul> <li>The <code>Push</code> operation adds a new element and stashes the currently active one \u2013 the stashed one will be removed from the view &amp; <code>STOPPED</code></li> <li>The <code>Pop</code> operation removes an element, the child <code>Node</code> will be <code>DESTROYED</code></li> </ul>"},{"location":"apps/plugins/","title":"Plugins","text":""},{"location":"apps/plugins/#keeping-extra-concerns-out-of-node","title":"Keeping extra concerns out of Node","text":"<p><code>Nodes</code> are meant to be simple structural elements, and should be kept lean.</p> <p>To keep the framework agnostic of any specific approach / pattern you want to use, there aren't any fixed parts. Rather, the <code>Node</code> offers an extension point using <code>Plugins</code> in its constructor:</p> <pre><code>abstract class Node(\nbuildContext: BuildContext,\nval view: NodeView = EmptyNodeView,\nplugins: List&lt;Plugin&gt; = emptyList() // &lt;--\n)\n</code></pre> <p>So what is a <code>Plugin</code>?</p> <p>A <code>Plugin</code> is an empty interface extended by many actual ones:</p> <pre><code>interface Plugin\n</code></pre>"},{"location":"apps/plugins/#plugins_1","title":"Plugins","text":""},{"location":"apps/plugins/#lifecycle-related-plugins","title":"Lifecycle-related plugins","text":"<pre><code>interface NodeLifecycleAware : Plugin {\nfun onCreate(lifecycle: Lifecycle) {}\n}\n\nfun interface Destroyable : Plugin {\nfun destroy()\n}\n</code></pre>"},{"location":"apps/plugins/#component-level-plugins","title":"Component level plugins","text":"<p>Sometimes you need to grab a reference to the component as a whole, either as an interface, or its implementation, the <code>Node</code>.</p> <p>This will come especially handy when working with workflows.</p> <pre><code>interface NodeAware : Plugin {\nval node: Node&lt;*&gt;\n\nfun init(node: Node&lt;*&gt;) {}\n}\n</code></pre> <p>There are helper classes found in the library, so you don't have to implement the above interfaces, you can just use delegation:</p> <pre><code>class SomeClass(\nprivate val nodeAware: NodeAware = NodeAwareImpl()\n) : NodeAware by nodeAware {\n\nfun foo() {\n// [node] is an automatically available property coming from the NodeAware interface\n// the reference is automatically set for you by the framework + the NodeAwareImpl class\n// so you can use it right away:\nnode.doSomething()\n}\n}\n</code></pre> <p>\u26a0\ufe0f Note: the reference to <code>node</code> is set by <code>Node</code> automatically, and isn't available immediately after constructing your object, but only after the construction of the <code>Node</code> itself.</p>"},{"location":"apps/plugins/#navigation-plugins","title":"Navigation plugins","text":"<p>In case if you need to control navigation behaviour, you can use these plugins:</p> <pre><code>interface UpNavigationHandler : Plugin {\nfun handleUpNavigation(): Boolean = false\n}\n\ninterface BackPressHandler : Plugin {\nval onBackPressedCallback: OnBackPressedCallback? get() = null\n}\n</code></pre> <p><code>UpNavigationHandler</code> controls <code>Node.navigateUp</code> behaviour and allows to intercept its invocation.</p> <p><code>BackPressHandler</code> controls device back press behaviour via <code>androidx.activity.OnBackPressedCallback</code>. You can read more about it here.</p> <p>\u26a0\ufe0f Note: <code>OnBackPressedCallback</code> are invoked in the following order: 1. From children to parents. Render order of children matters! The last rendered child will be the first to handle back press. 2. Direct order of plugins within a node. Plugins are invoked in order they appears in <code>Node(plugins = ...)</code> before the NavModel. </p>"},{"location":"apps/plugins/#using-plugins","title":"Using Plugins","text":"<p>All plugins are designed to have empty <code>{}</code> default implementations (or other sensible defaults when a return value is defined), so it's convenient to implement them only if you need.</p> <p>Don't forget to pass your <code>Plugins</code> to your <code>Node</code>:</p> <pre><code>internal class MyNode(\n// ...\nplugins: List&lt;Plugins&gt; = emptyList()\n// ...\n) : Node&lt;Nothing&gt;(\n// ...\nplugins = plugins\n// ...\n)\n</code></pre> <p>\u26a0\ufe0f Note: <code>plugins</code> is a <code>List</code>, as the order matters here. All <code>Plugin</code> instances are invoked in the order they appear in the list.</p>"},{"location":"apps/structure/","title":"Structuring your app navigation","text":"<p>As seen in Composable navigation, you can make <code>NavModels</code> composable. </p> <p>To achieve this, Appyx offers the <code>Node</code> class as the structural element.</p>"},{"location":"apps/structure/#node-illustration","title":"Node illustration","text":"<p>In many of the examples you'll see this panel as an illustration of a very simple <code>Node</code> \u2013 it has some local state (id, colour, and a counter).</p> <p></p> <p>If you launch the sample app in the <code>:app</code> module, you can also change its state (colour) by tapping it. Its counter is stepped automatically. This is to illustrate that it has its own state, persisted and restored.</p>"},{"location":"apps/structure/#node-overview","title":"Node overview","text":"<p>You can think of a <code>Node</code> as a standalone component with:</p> <ul> <li>Its own simplified lifecycle</li> <li>State restoration</li> <li>A <code>@Composable</code> view</li> <li>Business logic that's kept alive even when the view isn't added to the composition</li> <li>The ability to host generic Plugins to extract extra concerns without enforcing any particular architectural pattern</li> </ul>"},{"location":"apps/structure/#parent-nodes-child-nodes","title":"Parent nodes, child nodes","text":"<p><code>ParentNodes</code> can have other <code>Nodes</code> as children. This means you can represent your whole application as a tree of Appyx nodes.</p> <p></p> <p>You can go as granular or as high-level as it fits you. This allows to keep the complexity low in individual <code>Nodes</code> by extracting responsibilities to children, as well as composing other components to build more complex functionality.</p>"},{"location":"apps/structure/#composable-navigation","title":"Composable navigation","text":"<p><code>Nodes</code> offer the structure \u2013 <code>NavModels</code> add dynamism to it.</p> <p>Read more in Composable navigation</p>"},{"location":"apps/structure/#lifecycle","title":"Lifecycle","text":"<p>Nodes have their own lifecycles, directly using the related classes of <code>androidx.lifecycle</code>.</p> <p>Read more in Lifecycle</p>"},{"location":"apps/structure/#childaware-api","title":"ChildAware API","text":"<p>React to dynamically added child nodes in the tree: ChildAware API </p>"},{"location":"apps/structure/#summary","title":"Summary","text":"<p>A summary of Appyx's approach to structuring applications:</p> <ul> <li>Compose your app out of <code>Nodes</code> with their own lifecycles and state</li> <li>Navigation is local, composed of individual pieces of <code>NavModels</code></li> <li>Navigation is stateful</li> <li>Navigation is unit-testable</li> <li>You're free to implement your own navigable components by utilising <code>NavModels</code></li> <li>Avoid global navigation concerns, like shared modules needing to know about the application, or the application needing to know about all its possible modules</li> </ul>"},{"location":"how-to-use-appyx/codelabs/","title":"Appyx codelabs","text":"<p>When you feel ready, try our Coding challenges too!</p>"},{"location":"how-to-use-appyx/codelabs/#1-hello-world-with-appyx","title":"1. Hello World with Appyx","text":"<p>Learn the basics of Appyx</p> <p></p>"},{"location":"how-to-use-appyx/codelabs/#2-navigation","title":"2. Navigation","text":"<p>Learn how Appyx navigation works</p> <p></p>"},{"location":"how-to-use-appyx/codelabs/#3-custom-animation","title":"3. Custom animation","text":"<p>Learn how to unleash powerful transitions</p> <p></p>"},{"location":"how-to-use-appyx/coding-challenges/","title":"Appyx coding challenges","text":""},{"location":"how-to-use-appyx/coding-challenges/#droidcon-london-22-coding-challenge-1","title":"Droidcon London 22 \u2013 Coding challenge 1","text":"<p>Test your knowledge of the key pieces of Appyx</p> <p></p>"},{"location":"how-to-use-appyx/coding-challenges/#droidcon-london-22-coding-challenge-2","title":"Droidcon London 22 \u2013 Coding challenge 2","text":"<p>A challenge with custom animations and a new operation</p> <p></p>"},{"location":"how-to-use-appyx/quick-start/","title":"Quick start guide","text":"<p>Info</p> <ul> <li>You can check out App structure, which explains the concepts you'll encounter in this guide.</li> <li>You can check out the project and launch the <code>:app</code> module for a quick demonstration</li> </ul> <p>Tip</p> <p>Once you're familiar with Appyx, you can also clone the https://github.com/bumble-tech/appyx-starter-kit when starting a new project, instead of following this guide below.</p>"},{"location":"how-to-use-appyx/quick-start/#scope-of-this-guide","title":"Scope of this guide","text":"<p>The steps below will cover:</p> <ol> <li>Integrating Appyx into your project</li> <li>Creating a very simple <code>Node</code> hierarchy</li> <li>We'll use a simple back stack for navigation</li> <li>We'll add some simple transitions to it</li> </ol> <p>This should be enough to get you started as a rudimentary application structure.</p> <p>Tutorials &amp; codelabs on more advanced topics &amp; the full power of Appyx to follow soon.</p>"},{"location":"how-to-use-appyx/quick-start/#1-add-appyx-to-your-project","title":"1. Add Appyx to your project","text":"<p>You can find the related Gradle dependencies in Downloads.</p>"},{"location":"how-to-use-appyx/quick-start/#2-create-a-root-node","title":"2. Create a root Node","text":"<pre><code>class RootNode(\nbuildContext: BuildContext\n) : Node(\nbuildContext = buildContext\n) {\n@Composable\noverride fun View(modifier: Modifier) {\nText(\"Hello world!\")\n}\n}\n</code></pre> <p>Since this is the root of your tree, you'll also need to plug it in to your Activity, so that system events (Android lifecycle, back press, etc.) reach your components in the tree.</p> <pre><code>// Please note we are extending NodeActivity\nclass MainActivity : NodeActivity() {\n\noverride fun onCreate(savedInstanceState: Bundle?) {\nsuper.onCreate(savedInstanceState)\nsetContent {\nAppTheme {\nNodeHost(integrationPoint = appyxIntegrationPoint) {\nRootNode(buildContext = it)\n}\n}\n}\n}\n}\n</code></pre> <p>You only need to do this for the root of the tree.</p>"},{"location":"how-to-use-appyx/quick-start/#3-define-children","title":"3. Define children","text":"<p>A single leaf node isn't all that interesting. Let's add some children to the root!</p> <p>First, let's define the possible set of children using a sealed class. We'll refer them via these navigation targets:</p> <pre><code>/**\n * You can create this class inside the body of RootNode\n * \n * Note: You must apply the 'kotlin-parcelize' plugin to use @Parcelize\n * https://developer.android.com/kotlin/parcelize\n */\nsealed class NavTarget : Parcelable {\n@Parcelize\nobject Child1 : NavTarget()\n\n@Parcelize\nobject Child2 : NavTarget()\n\n@Parcelize\nobject Child3 : NavTarget()\n}\n</code></pre> <p>Next, let's modify <code>RootNode</code> so it extends <code>ParentNode</code>:</p> <pre><code>class RootNode(\nbuildContext: BuildContext\n) : ParentNode&lt;NavTarget&gt;(\nnavModel = TODO(\"We will come back to this in Step 4\"),\nbuildContext = buildContext\n) {\n</code></pre> <p><code>ParentNode</code> expects us to implement the abstract method <code>resolve</code>. This is how we relate navigation targets to actual children. Let's use these helper methods to define some placeholders for the time being \u2013 we'll soon make them more appealing:</p> <pre><code>override fun resolve(navTarget: NavTarget, buildContext: BuildContext): Node =\nwhen (navTarget) {\nNavTarget.Child1 -&gt; node(buildContext) { Text(text = \"Placeholder for child 1\") }\nNavTarget.Child2 -&gt; node(buildContext) { Text(text = \"Placeholder for child 2\") } NavTarget.Child3 -&gt; node(buildContext) { Text(text = \"Placeholder for child 3\") }\n}\n</code></pre> <p>Great! With this mapping created, we can now just refer to children using the sealed class elements, and Appyx will be able to relate them to other nodes.</p>"},{"location":"how-to-use-appyx/quick-start/#4-add-a-back-stack","title":"4. Add a back stack","text":"<p>The project wouldn't compile just yet. <code>ParentNode</code> expects us to pass an instance of a <code>NavModel</code> \u2013 the main control structure in any case when we want to add children. No need to worry now \u2013 for simplicity, let's just go with a simple <code>BackStack</code> implementation here:</p> <pre><code>class RootNode(\nbuildContext: BuildContext,\nprivate val backStack: BackStack&lt;NavTarget&gt; = BackStack(\ninitialElement = NavTarget.Child1,\nsavedStateMap = buildContext.savedStateMap,\n)\n) : ParentNode&lt;NavTarget&gt;(\nnavModel = backStack, // pass it here\nbuildContext = buildContext\n) {\n</code></pre> <p>With this simple addition we've immediately gained a lot of power! Now we can use the back stack's API to add, replace, pop children with operations like:</p> <pre><code>backStack.push(NavTarget.Child2)    // will add a new navigation target to the end of the stack and make it active \nbackStack.replace(NavTarget.Child3) // will replace the currently active child\nbackStack.pop()                     // will remove the currently active child and restore the one before it\n</code></pre> <p>Since we passed the back stack to the <code>ParentNode</code>, all such changes will be immediately reflected. We only need to add it to the composition:</p> <pre><code>@Composable\noverride fun View(modifier: Modifier) {\nColumn {\nText(\"Hello world!\")\n// Let's add the children to the composition\nChildren(\nnavModel = backStack\n)\n\n// Let's also add some controls so we can test it\nRow {\nTextButton(onClick = { backStack.push(NavTarget.Child1) }) {\nText(text = \"Push child 1\")\n}\nTextButton(onClick = { backStack.push(NavTarget.Child2) }) {\nText(text = \"Push child 2\")\n}\nTextButton(onClick = { backStack.push(NavTarget.Child3) }) {\nText(text = \"Push child 3\")\n}\nTextButton(onClick = { backStack.pop() }) {\nText(text = \"Pop\")\n}\n}\n}\n}\n</code></pre>"},{"location":"how-to-use-appyx/quick-start/#5-add-transitions","title":"5. Add transitions","text":"<p>Adding some transitions is a one-liner:</p> <pre><code>Children(\nnavModel = backStack,\ntransitionHandler = rememberBackstackSlider()\n)\n</code></pre> <p>You can also use a fader instead: <code>rememberBackstackFader()</code>, and you can supply a transition spec in both cases: <code>rememberBackStackSlider { spring(stiffness = Spring.StiffnessLow) }</code></p> <p>Need something more custom?</p> <ol> <li>Instead of a back stack, you can find other NavModels in the library, or you can implement your own</li> <li>Instead of the default transition handlers, you can also use Jetpack Compose provided ones, or supply your own</li> </ol> <p>You can also read the Back stack documentation for more info on the specific options for the back stack.</p>"},{"location":"how-to-use-appyx/quick-start/#6-proper-child-nodes","title":"6. Proper child nodes","text":"<p>As a last step, let's replace at least one of the child placeholders with another proper node.</p> <p>Let's create a dedicated class:</p> <pre><code>class SomeChildNode(\nbuildContext: BuildContext\n) : Node(\nbuildContext = buildContext\n) {\n@Composable\noverride fun View(modifier: Modifier) {\nText(\"This is SomeChildNode\")\n}\n}\n</code></pre> <p>Now we can update the <code>resolve</code> method in <code>RootNode</code> so that the target <code>Child3</code> refers to this node. It should work out of the box:</p> <pre><code>override fun resolve(navTarget: NavTarget, buildContext: BuildContext): Node =\nwhen (navTarget) {\nNavTarget.Child1 -&gt; node(buildContext) { Text(text = \"Placeholder for child 1\") }\nNavTarget.Child2 -&gt; node(buildContext) { Text(text = \"Placeholder for child 2\") } NavTarget.Child3 -&gt; SomeChildNode(buildContext)\n}\n</code></pre>"},{"location":"how-to-use-appyx/quick-start/#whats-next","title":"What's next?","text":"<p>Congrats, you've just built your first Appyx tree!</p> <p>You can repeat the same pattern and make any embedded children also a <code>ParentNode</code> with their own children, navigation models, and transitions. As complexity grows, generally you would:</p> <ol> <li>Have a <code>Node</code></li> <li>At some point make it a <code>ParentNode</code> and add children to it</li> <li>At some point extract the increasing complexity from a placeholder to another <code>Node</code> </li> <li>Repeat the same on children, go to <code>1.</code></li> </ol>"},{"location":"how-to-use-appyx/quick-start/#further-reading","title":"Further reading","text":"<ul> <li>Check out Model-driven navigation how to take your navigation to the next level</li> <li>You can (and probably should) also extract local business logic, the view, any any other components into separate classes and Plugins.</li> </ul>"},{"location":"how-to-use-appyx/sample-apps/","title":"Appyx sample apps","text":""},{"location":"how-to-use-appyx/sample-apps/#where-to-find-the-sample-apps","title":"Where to find the sample apps","text":"<ol> <li>Go to the GitHub project</li> <li>Fork and check out the code locally</li> <li>Import the project to Android Studio</li> </ol> <p>You can find the pre-built sample app apks here:</p> <ul> <li>Latest release</li> <li>Latest 1.x</li> </ul>"},{"location":"how-to-use-appyx/sample-apps/#showcase-app","title":"Showcase app","text":"<p>The <code>:app</code> module showcases Appyx itself with multiple levels of navigation, NavModel demos, etc. See it in action, then check the related code how it works.</p>"},{"location":"how-to-use-appyx/sample-apps/#appyx-jetpack-compose-navigation-example","title":"Appyx + Jetpack Compose Navigation example","text":"<p>The <code>:samples:navigation-compose</code> module demonstrates how to use Appyx within Google's Jetpack Compose Navigation library. This example may be useful if you need to migrate to Appyx gradually.</p>"},{"location":"how-to-use-appyx/sample-apps/#appyx-hilt-example","title":"Appyx + Hilt example","text":"<p>Coming soon!</p> <p>Meanwhile:</p> <ul> <li>Our draft PR: #115 (Feel free to provide feedback!)</li> <li>https://github.com/jbreitfeller-sfix/appyx-playground another approach on this topic</li> </ul>"},{"location":"navigation/composable-navigation/","title":"Composable navigation","text":"<p>NavModels in Appyx are composable. </p> <p>As a single <code>NavModel</code> won't be enough for the whole of your whole app, you can use many in a composable way. That is, any navigation target of a <code>NavModel</code> can also host its own <code>NavModel</code>.</p>"},{"location":"navigation/composable-navigation/#structural-element-for-composing-navigation","title":"Structural element for composing navigation","text":"<p><code>Nodes</code> are the main structural element in Appyx. They can host <code>NavModels</code>, and they form a tree.</p> <p>This allows you to make your app's business logic also composable by leveraging <code>Nodes</code> as lifecycled components.</p> <p>Read more in Structuring your app navigation</p>"},{"location":"navigation/composable-navigation/#navigation-in-the-tree","title":"Navigation in the tree","text":"<p>Once you've structured your navigation in a composable way, you can add <code>NavModels</code> to <code>Node</code> of this tree and make it dynamic:</p> <ul> <li>Some parts in this tree are active while others ore not</li> <li>The active parts define what state the application is in, and what the user sees on the screen</li> <li>We can change what's active by using <code>NavModels</code> on each level of the tree</li> <li>Changes will feel like navigation to the user</li> </ul> <p>See Implicit navigation and Explicit navigation for building complex navigation behaviours with this approach.</p>"},{"location":"navigation/composable-navigation/#how-navmodels-affect-nodes","title":"How NavModels affect Nodes","text":"<p>NavModel operations will typically result in:</p> <ul> <li>Adding or removing child <code>Nodes</code> of a <code>ParentNode</code></li> <li>Move them on and off the screen</li> <li>Change their states</li> </ul> <p>As an illustration:</p> <p> </p> <p>Here:</p> <ul> <li><code>Back stack</code> illustrates adding and removing child <code>Nodes</code></li> <li><code>Tiles</code> illustrates changing the state of children and removing them from the <code>ParentNode</code></li> </ul> <p>These are just two examples, you're of course not limited to using them.</p>"},{"location":"navigation/deep-linking/","title":"Deep linking","text":"<p>Building on top of explicit navigation, implementing deep links is straightforward:</p> <pre><code>class ExplicitNavigationExampleActivity : NodeActivity(), Navigator {\n\nlateinit var rootNode: RootNode\n\nfun handleDeepLink(intent: Intent) {\nif (intent.action == Intent.ACTION_VIEW) {\nwhen {\n(it.data?.host == \"onboarding\") -&gt; navigateToOnBoarding()\nelse -&gt; Unit\n}\n}\n}\n\noverride fun onCreate(savedInstanceState: Bundle?) {\nsuper.onCreate(savedInstanceState)\nsetContent {\nNodeHost(integrationPoint = appyxIntegrationPoint) {\nRootNode(\nbuildContext = it,\nplugins = listOf(object : NodeReadyObserver&lt;RootNode&gt; {\noverride fun init(node: RootNode) {\nrootNode = node\nhandleDeepLink(intent = intent)\n}\n})\n)\n}\n}\n}\n\nprivate fun navigateToOnBoarding() {\n// implement explicit navigation\n}\n}\n</code></pre> <p>Check <code>ExplicitNavigationExampleActivity</code> in the samples to inspect the full code.</p>"},{"location":"navigation/explicit-navigation/","title":"Explicit navigation","text":"<p>When Implicit navigation doesn't fit your use case, you can try an explicit approach.</p> <p>Relevant methods</p> <ul> <li>ParentNode.attachChild()</li> <li>ParentNode.waitForChildAttached()</li> </ul> <p>Using these methods we can chain together a path which leads from the root of the tree to a specific <code>Node</code>.</p>"},{"location":"navigation/explicit-navigation/#use-case","title":"Use case","text":"<p>We want to navigate from <code>Chat</code></p> <p></p> <p>to onboarding's first screen <code>O1</code>:</p> <p></p> <p>This time we'll want to do this explicitly by calling a function.</p>"},{"location":"navigation/explicit-navigation/#the-plan","title":"The plan","text":"<ol> <li>Create a public method on <code>Root</code> that attaches <code>Onboarding</code></li> <li>Create a public method on <code>Onboarding</code> that attaches the first onboarding screen</li> <li>Create a <code>Navigator</code>, that starting from an instance of <code>Root</code>, can chain these public methods together into a single action: <code>navigateToO1()</code></li> <li>Capture an instance of <code>Root</code> to use with <code>Navigator</code></li> <li>Call <code>navigateToO1()</code> on our <code>Navigator</code> instance</li> </ol>"},{"location":"navigation/explicit-navigation/#step-1-root-onboarding","title":"Step 1 \u2013 <code>Root</code> \u2192 <code>Onboarding</code>","text":"<p>First, we need to define how to programmatically attach <code>Onboarding</code> to the <code>Root</code>:</p> <pre><code>class RootNode(\nbuildContext: BuildContext,\nbackStack: BackStack&lt;NavTarget&gt;\n) : ParentNode&lt;NavTarget&gt;(\nbuildContext = buildContext,\nnavModel = backStack,\n) {\n\nsuspend fun attachOnboarding(): OnboardingNode {\nreturn attachChild {\nbackStack.replace(NavTarget.Onboarding)\n}\n}\n}\n</code></pre> <p>Let's break down what happens here:</p> <ol> <li>Since <code>attachChild</code> has a generic <code>&lt;T&gt;</code> return type, it will conform to the defined <code>OnboardingNode</code> type </li> <li>However, <code>attachChild</code> doesn't know how to create navigation to <code>OnboardingNode</code> \u2013 that's something only we can do with the provided lambda</li> <li>We replace <code>NavTarget.Onboarding</code> into the back stack</li> <li>Doing this should result in <code>OnboardingNode</code> being created and added to <code>RootNode</code> as a child </li> <li><code>attachChild</code> expects an instance of <code>OnboardingNode</code> to appear as a child of <code>Root</code> as a consequence of executing our lambda</li> <li>Once it appears, <code>attachChild</code> returns it</li> </ol> <p>Important</p> <p>It's our responsibility to make sure that the provided lambda actually results in the expected child being added. If we accidentally do something else instead, for example:</p> <pre><code>suspend fun attachOnboarding(): OnboardingNode {\nreturn attachChild {\nbackStack.replace(NavTarget.Main) // Wrong NavTarget\n}\n}\n</code></pre> <p>Then an exception will be thrown after a timeout.</p>"},{"location":"navigation/explicit-navigation/#step-2-onboarding-o1","title":"Step 2 \u2013 <code>Onboarding</code> \u2192 <code>O1</code>","text":"<p>Unlike <code>Root</code>, <code>Onboarding</code> uses Spotlight instead of BackStack as a <code>NavModel</code>, so navigation to the first screen is slightly different:  </p> <pre><code>class OnboardingNode(\nbuildContext: BuildContext,\nspotlight: Spotlight&lt;NavTarget&gt;\n) : ParentNode&lt;NavTarget&gt;(\nbuildContext = buildContext,\nnavModel = spotlight,\n) {\n\nsuspend fun attachO1(): O1Node {\nreturn attachChild {\nspotlight.activate(index = 0)\n}\n}\n}\n</code></pre>"},{"location":"navigation/explicit-navigation/#step-3-our-navigator","title":"Step 3 \u2013 Our <code>Navigator</code>","text":"<pre><code>interface Navigator {\nfun navigateToO1()\n}\n</code></pre> <p>In this case we'll implement it directly with our activity:</p> <pre><code>class ExplicitNavigationExampleActivity : NodeActivity(), Navigator {\n\nlateinit var rootNode: RootNode // See the next step\n\noverride fun navigateToO1() {\nlifecycleScope.launch {\nrootNode\n.attachOnboarding()\n.attachO1()\n}\n}\n}\n</code></pre>"},{"location":"navigation/explicit-navigation/#step-4-an-instance-of-rootnode","title":"Step 4 \u2013 An instance of <code>RootNode</code>","text":"<p>As the last piece of the puzzle, we'll also need to capture the instance of <code>RootNode</code> to make it all work. We can do that by a <code>NodeReadyObserver</code> plugin when setting up our tree:</p> <pre><code>class ExplicitNavigationExampleActivity : NodeActivity(), Navigator {\n\nlateinit var rootNode: RootNode\n\noverride fun navigateToO1() { /*...*/ }\n\noverride fun onCreate(savedInstanceState: Bundle?) {\nsuper.onCreate(savedInstanceState)\nsetContent {\nNodeHost(integrationPoint = appyxIntegrationPoint) {\nRootNode(\nbuildContext = it,\nnavigator = this@ExplicitNavigationExampleActivity,\nplugins = listOf(object : NodeReadyObserver&lt;RootNode&gt; {\noverride fun init(node: RootNode) {\nrootNode = node\n}\n})\n)\n}\n}\n}\n}\n</code></pre>"},{"location":"navigation/explicit-navigation/#step-5-using-the-navigator","title":"Step 5 \u2013 Using the <code>Navigator</code>","text":"<p>See how in the previous snippet <code>RootNode</code> receives a <code>navigator</code> dependency. </p> <p>It can pass it further down the tree as a dependency to other nodes. Those nodes can call the methods of the <code>Navigator</code>, which will change the global navigation state directly.</p>"},{"location":"navigation/explicit-navigation/#bonus-wait-for-a-child-to-be-attached","title":"Bonus: Wait for a child to be attached","text":"<p>There might be cases when we want to wait for a certain action to be performed by the user, rather than us, to result in a child being attached.</p> <p>In these cases we can use <code>ParentNode.waitForChildAttached()</code> instead.</p>"},{"location":"navigation/explicit-navigation/#use-case-wait-for-login","title":"Use case \u2013 Wait for login","text":"<p>A typical case building an explicit navigation chain that relies on <code>Logged in</code> being attached. Most probably <code>Logged in</code> has a dependency on some kind of a <code>User</code> object. Here we want to wait for the user to authenticate themselves, rather than creating a dummy user object ourselves.</p> <pre><code>class RootNode(\nbuildContext: BuildContext,\n) : ParentNode&lt;NavTarget&gt;(\nbuildContext = buildContext\n) {\n\nsuspend fun waitForLoggedIn(): LoggedInNode = waitForChildAttached&lt;LoggedInNode&gt;()\n}\n</code></pre> <p>This method will wait for <code>LoggedInNode</code> to appear in the child list of <code>RootNode</code> and return with it. If it's already there, it returns immediately.</p> <p>A navigation chain using it could look like:</p> <pre><code>class ExplicitNavigationExampleActivity : NodeActivity(), Navigator {\n\noverride fun navigateToProfile() {\nlifecycleScope.launch {\nrootNode\n.waitForLoggedIn()\n.attachMain()\n.attachProfile()\n}\n}\n}\n</code></pre> <p>You can find related code examples in <code>ExplicitNavigationExampleActivity</code> in our samples.</p>"},{"location":"navigation/implicit-navigation/","title":"Implicit navigation","text":"<p>How can we go from one part of the tree to another? In almost all cases navigation can be implicit instead of explicit. We don't need to specify the target \u2013 navigation will happen as a consequence of individual pieces of the puzzle.</p> <p>Relevant methods</p> <ul> <li><code>ParentNode.onChildFinished(child: Node)</code> can be overridden by client code to handle a child finishing</li> <li><code>Node.finish()</code> invokes the above method on its parent</li> </ul>"},{"location":"navigation/implicit-navigation/#use-case-1","title":"Use-case 1","text":""},{"location":"navigation/implicit-navigation/#requirement","title":"Requirement","text":"<p>After onboarding finishes, the user should land in the message list screen.</p>"},{"location":"navigation/implicit-navigation/#solution","title":"Solution","text":"<ol> <li><code>O3</code> calls its <code>finish()</code> method</li> <li><code>Onboarding</code> notices <code>O3</code> finished; if it had more children, it could switch to another; now it calls <code>finish()</code> too</li> <li><code>Logged in</code> notices <code>Onboarding</code> finished, and switches its navigation to <code>Main</code></li> <li><code>Main</code> is initialised, and loads its default navigation target (based on product requirements) to be <code>Messages</code></li> <li><code>Messages</code> is initialised, and loads its default navigation target to be <code>List</code></li> </ol> <p>Bonus</p> <p>Every <code>Node</code> in the above sequence only needed to care about its own local concern.</p>"},{"location":"navigation/implicit-navigation/#use-case-2","title":"Use-case 2","text":""},{"location":"navigation/implicit-navigation/#requirement_1","title":"Requirement","text":"<p>Pressing the logout button on the profile screen should land us back to the login screen.</p>"},{"location":"navigation/implicit-navigation/#solution_1","title":"Solution","text":"<ol> <li><code>Root</code> either implements a <code>logout</code> callback, or subscribes to the changes of a user repository; in both cases, either the callback or the repository is passed down the tree as a dependency</li> <li><code>Profile</code> invokes the callback or a <code>logout</code> method on the repository</li> <li><code>Root</code> notices the state change, and switches its navigation to the <code>Logged out</code> scope</li> <li><code>Logged out</code> loads its initial navigation target, <code>Login</code></li> </ol> <p>Bonus</p> <p>Note how the entire <code>Logged in</code> scope is destroyed without any extra effort. The next time a login happens, all state is created anew. </p>"},{"location":"navigation/implicit-navigation/#summary","title":"Summary","text":"<p>Implicit navigation allows you to implement navigation without introducing unnecessary coupling in the tree, and successfully covers the majority of navigation scenarios.</p> <p>In case it's not enough to meet your needs, see the next chapter, Explicit navigation</p>"},{"location":"navigation/model-driven-navigation/","title":"Model-driven navigation","text":""},{"location":"navigation/model-driven-navigation/#your-own-navigation-model","title":"Your own navigation model","text":"<p>Generally speaking, most navigation solutions have fixed navigation mechanisms (e.g. a back stack).</p> <p>Appyx gives you the freedom to define your own navigation model. For example, you can implement any of the examples you see here with the same approach:</p> <p> </p>"},{"location":"navigation/model-driven-navigation/#no-screen-only-a-viewport","title":"No screen, only a viewport","text":"<p>Generally speaking, most navigation solutions model a \"Screen\" and focus on how to get from one screen to another.</p> <p>Appyx does not have the concept of the screen in its model \u2013 there's only a viewport, and whatever fills the available space will feel like the screen to the user.</p> <p>This freedom allows you to implement:</p> <ul> <li>navigation that feels like going from \"screen to screen\"</li> <li>navigation \"inside the screen\"</li> <li>navigation that bridges between the two</li> </ul> <p>For example, you can transform the screen itself as part of navigation:</p> <p></p>"},{"location":"navigation/model-driven-navigation/#navmodels","title":"NavModels","text":"<p>A <code>NavModel</code> implements any of the above mechanisms. </p> <p>See NavModels for more details. </p>"},{"location":"navigation/model-driven-navigation/#composable-navigation","title":"Composable navigation","text":"<p><code>NavModels</code> in Appyx are composable.</p> <p>See Composable navigation for more details.</p>"},{"location":"navmodel/","title":"Navigation models","text":"<p>Navigation model is a core concept of Appyx.</p>"},{"location":"navmodel/#whats-a-navmodel","title":"What's a NavModel?","text":"<p>Navigation models describe navigation itself \u2013 by the states and operations they define, any custom navigation mechanism can be implemented.</p> <p><code>NavModel</code> capabilities differ across implementations, however, typically:</p> <ol> <li>They store information on the states of all children </li> <li>They behave like a state machine</li> <li>They offer some public API to trigger changing the state of children  </li> </ol>"},{"location":"navmodel/#some-examples-of-navigation-models","title":"Some examples of navigation models","text":"<p>You can take a look at some of these examples:</p> <ol> <li>Back stack</li> <li>Spotlight</li> <li>Tiles</li> <li>Promoter carousel</li> </ol> <p>When you feel ready, you can try to implement your own NavModel.</p>"},{"location":"navmodel/#what-does-a-navmodel-not-do","title":"What does a NavModel not do?","text":"<p>The <code>NavModel</code> represents only the model, not the looks:</p> <ul> <li>UI representation depends on your <code>@Composable</code> view hosting the children \u2013 See Adding children to the view</li> <li>Transition animations (if any) is a separate concern</li> </ul>"},{"location":"navmodel/backstack/","title":"Back stack","text":"<p>Implements a simple linear history:</p> <ul> <li>The last element at the end of the stack is considered \"active\".</li> <li>All other elements are considered stashed.</li> <li>Children associated with stashed elements are off the screen but kept alive (see how the counter values reflect this on the video)</li> </ul> <p>The back stack can never be empty \u2013 it always contains at least one element.</p> <p>The back stack also supports different back press and operation strategies (see further down below).</p>"},{"location":"navmodel/backstack/#states","title":"States","text":"<pre><code>enum class State {\nCREATED, ACTIVE, STASHED, DESTROYED,\n}\n</code></pre>"},{"location":"navmodel/backstack/#visualisation-of-states","title":"Visualisation of states","text":"<p>Check out the apps in our Coding challenges \u2013 they have an embedded visualisation of what happens to all the elements inside the back stack (look at the row of orange boxes below the logo). </p>"},{"location":"navmodel/backstack/#constructing-the-back-stack","title":"Constructing the back stack","text":"<p>As the back stack can never be empty, it's required to define an initial target.</p> <pre><code>class BackStack&lt;NavTarget : Any&gt;(\ninitialElement: NavTarget,\nsavedStateMap: SavedStateMap?,\n// Optional parameters are omitted\n)\n</code></pre>"},{"location":"navmodel/backstack/#default-on-screen-resolution","title":"Default on screen resolution","text":"<p>As a default, only the active element is considered on screen.</p> <pre><code>object BackStackOnScreenResolver : OnScreenStateResolver&lt;State&gt; {\noverride fun isOnScreen(state: State): Boolean =\nwhen (state) {\nState.CREATED,\nState.STASHED,\nState.DESTROYED -&gt; false\nState.ACTIVE -&gt; true\n}\n}\n</code></pre>"},{"location":"navmodel/backstack/#default-transition-handlers","title":"Default transition handlers","text":""},{"location":"navmodel/backstack/#backstackfader","title":"BackStackFader","text":"<p><code>rememberBackstackFader()</code></p> <p>Adds simple cross-fading transitions</p>"},{"location":"navmodel/backstack/#backstackslider","title":"BackStackSlider","text":"<p><code>rememberBackstackSlider()</code></p> <p>Adds horizontal sliding transitions so that the <code>ACTIVE</code> element is in the center; other states are animated from / to the left or the right edge of the screen.</p>"},{"location":"navmodel/backstack/#operations","title":"Operations","text":""},{"location":"navmodel/backstack/#push","title":"Push","text":"<p><code>backStack.push(navTarget)</code></p> <p>Effect on stack:  <pre><code>[A, B, C] + Push(D) = [A, B, C, D]\n</code></pre></p> <p>Transitions the active element <code>ACTIVE</code> -&gt; <code>STASHED</code>. Adds a new element at the end of the stack with a <code>CREATED</code> -&gt; <code>ACTIVE</code> transition.</p>"},{"location":"navmodel/backstack/#replace","title":"Replace","text":"<p><code>backStack.replace(navTarget)</code></p> <p>Effect on stack:  <pre><code>[A, B, C] + Replace(D) = [A, B, D]\n</code></pre></p> <p>Transitions the active element <code>ACTIVE</code> -&gt; <code>DESTROYED</code>, which will be removed when the transition finishes. Adds a new element at the end of the stack with a <code>CREATED</code> -&gt; <code>ACTIVE</code> transition.</p>"},{"location":"navmodel/backstack/#pop","title":"Pop","text":"<p><code>backStack.pop(navTarget)</code></p> <p>Effect on stack:  <pre><code>[A, B, C] + Pop = [A, B]\n</code></pre></p> <p>Transitions the active element <code>ACTIVE</code> -&gt; <code>DESTROYED</code>, which will be removed when the transition finishes. Transitions the last stashed element <code>STASHED</code> -&gt; <code>ACTIVE</code>.</p>"},{"location":"navmodel/backstack/#single-top","title":"Single top","text":"<p><code>backStack.singleTop(navTarget)</code></p> <p>Effect on stack: depends on the contents of the stack:</p> <pre><code>[A, B, C, D] + SingleTop(B)  = [A, B]          // of same type and equals, acts as n * Pop\n[A, B, C, D] + SingleTop(B') = [A, B']         // of same type but not equals, acts as n * Pop + Replace\n[A, B, C, D] + SingleTop(E)  = [A, B, C, D, E] // not found, acts as Push\n</code></pre>"},{"location":"navmodel/backstack/#back-press-strategy","title":"Back press strategy","text":"<p>You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own.</p> <pre><code>class BackStack&lt;NavTarget : Any&gt;(\n/* ... */\nbackPressHandler: BackPressHandlerStrategy&lt;NavTarget, State&gt; = PopBackPressHandler(),\n/* ... */\n) </code></pre>"},{"location":"navmodel/backstack/#popbackpresshandler","title":"PopBackPressHandler","text":"<p>The default back press handling strategy. Runs a <code>Pop</code> operation.</p>"},{"location":"navmodel/backstack/#donthandlebackpress","title":"DontHandleBackPress","text":"<p>Serves as a no-op.</p>"},{"location":"navmodel/backstack/#operation-strategy","title":"Operation strategy","text":"<p>You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own.</p> <pre><code>class BackStack&lt;NavTarget : Any&gt;(\n/* ... */\noperationStrategy: OperationStrategy&lt;NavTarget, State&gt; = ExecuteImmediately(),    /* ... */\n)\n</code></pre>"},{"location":"navmodel/backstack/#executeimmediately","title":"ExecuteImmediately","text":"<p>The default strategy. New operations are executed without any questions, regardless of any already running transitions.</p>"},{"location":"navmodel/backstack/#finishtransitionsonnewoperation","title":"FinishTransitionsOnNewOperation","text":"<p>All running transitions are abruptly finished when a new one is started</p>"},{"location":"navmodel/backstack/#queueoperations","title":"QueueOperations","text":"<p>The new operation is queued and executed after the current one finishes</p>"},{"location":"navmodel/backstack/#ignoreifthereareunfinishedtransitions","title":"IgnoreIfThereAreUnfinishedTransitions","text":"<p>Runs the new one only if there are no transitions happening currently; ignore and discard it otherwise</p>"},{"location":"navmodel/cards/","title":"Cards","text":"<p>Implements a dating-cards-like mechanism.</p> <p>Intended only as an illustration, but it should be easy enough to tailor it to your needs if you find it useful.</p>"},{"location":"navmodel/cards/#where-can-i-find-this-navmodel","title":"Where can I find this NavModel?","text":"<p>The <code>Cards</code> NavModel is not currently published, however you can try it in <code>:samples:app</code>. Launch the sample app and check the <code>Dating cards NavModel</code> item to see it in action.</p>"},{"location":"navmodel/cards/#states","title":"States","text":"<pre><code>sealed class State {\ndata class Queued(val queueNumber: Int) : State()\nobject Bottom : State()\nobject Top : State()\nobject IndicateLike : State()\nobject IndicatePass : State()\nobject VoteLike : State()\nobject VotePass : State()\n}\n</code></pre>"},{"location":"navmodel/cards/#state-transitions","title":"State transitions","text":""},{"location":"navmodel/cards/#constructing-cards","title":"Constructing <code>Cards</code>","text":"<p>Requires defining items that will be converted to profile cards. The first one in the list will become a <code>Top</code> card, the second one a <code>Bottom</code> card, the rest will be <code>Queued</code>. </p> <pre><code>class Cards&lt;NavTarget : Any&gt;(\ninitialItems: List&lt;NavTarget&gt; = listOf(),\n) : BaseNavModel&lt;NavTarget, State&gt;(\nscreenResolver = CardsOnScreenResolver,\nfinalStates = FINAL_STATES,\nsavedStateMap = null\n) {\ncompanion object {\ninternal val FINAL_STATES = setOf(VoteLike, VotePass)\ninternal val TOP_STATES = setOf(Top, IndicateLike, IndicatePass)\n}\n}\n</code></pre>"},{"location":"navmodel/cards/#default-on-screen-resolution","title":"Default on screen resolution","text":"<pre><code>internal object CardsOnScreenResolver : OnScreenStateResolver&lt;State&gt; {\noverride fun isOnScreen(state: State): Boolean =\nwhen (state) {\nis State.Bottom,\nis State.Top,\nis State.IndicateLike,\nis State.IndicatePass -&gt; true\nis State.Queued,\nis State.VoteLike,\nis State.VotePass -&gt; false\n}\n}\n</code></pre>"},{"location":"navmodel/cards/#default-transition-handlers","title":"Default transition handlers","text":""},{"location":"navmodel/cards/#cardstransitionhandler","title":"CardsTransitionHandler","text":"<p><code>rememberCardsTransitionHandler()</code></p> <p>Adds scale-up, swipe and rotation animations.</p>"},{"location":"navmodel/cards/#operations","title":"Operations","text":""},{"location":"navmodel/cards/#promoteall","title":"PromoteAll","text":"<p>Internal operation. Automatically invoked whenever a top card is moved to a vote-related state. Causes all other cards to come forward in the queue, become the <code>Bottom</code> card, then the <code>Top</code> card.</p>"},{"location":"navmodel/cards/#indicatelike-indicatepass-votelike-votepass","title":"IndicateLike, IndicatePass, VoteLike, VotePass","text":"<p>Transitions the <code>Top</code> card directly to these states.</p>"},{"location":"navmodel/custom/","title":"Implementing your own navigation models","text":"<p>A step-by-step guide. You can also take a look at other existing examples to see these in practice.</p>"},{"location":"navmodel/custom/#step-1","title":"Step 1","text":"<p>Create the class; define your possible states; define your initial state. </p> <pre><code>class Foo&lt;NavTarget : Any&gt;(\ninitialItems: List&lt;NavTarget&gt; = listOf(),\nsavedStateMap: SavedStateMap?\n) : BaseNavModel&lt;NavTarget, Foo.State&gt;(\nscreenResolver = FooOnScreenResolver, // We'll see about this shortly\nfinalState = DESTROYED, // Anything transitioning towards this state will be discarded eventually\nsavedStateMap = savedStateMap // It's nullable if you don't need state restoration\n) {\n\n// Your possible states for any single navigation target\nenum class State {\nCREATED, FOO, BAR, BAZ, DESTROYED;\n}\n\n// You can go about it any other way.\n// Back stack for example defines only a single element.\n// Here we take all the &lt;NavTarget&gt; elements and make them transition CREATED -&gt; FOO immediately.\noverride val initialElements = initialItems.map {\nFooElement(\nkey = NavKey(it),\nfromState = State.CREATED,\ntargetState = State.FOO,\noperation = Operation.Noop()\n)\n}\n}\n</code></pre>"},{"location":"navmodel/custom/#optional-step-2","title":"(optional) Step 2","text":"<p>Add some convenience aliases:</p> <pre><code>typealias FooElement&lt;NavTarget&gt; = NavElement&lt;NavTarget, Foo.State&gt;\n\ntypealias FooElements&lt;NavTarget&gt; = NavElements&lt;NavTarget, Foo.State&gt;\n\nsealed interface FooOperation&lt;NavTarget&gt; : Operation&lt;NavTarget, Foo.State&gt;\n</code></pre>"},{"location":"navmodel/custom/#step-3","title":"Step 3","text":"<p>Define one or more operations.</p> <pre><code>@Parcelize\nclass SomeOperation&lt;NavTarget : Any&gt; : FooOperation&lt;NavTarget&gt; {\n\noverride fun isApplicable(elements: FooElements&lt;NavTarget&gt;): Boolean =\nTODO(\"Define whether this operation is applicable given the current state\")\n\noverride fun invoke(\nelements: FooElements&lt;NavTarget&gt;,\n): NavElements&lt;NavTarget, Foo.State&gt; =\n// TODO: Mutate elements however you please. Add, remove, change.\n//  In this example we're changing all elements to transition to BAR.\n//  You can also use helper methods elements.transitionTo &amp; elements.transitionToIndexed \nelements.map {\nit.transitionTo(\nnewTargetState = BAR,\noperation = this\n)\n}\n}\n\n// You can add an extension method for a leaner API\nfun &lt;NavTarget : Any&gt; Foo&lt;NavTarget&gt;.someOperation() {\naccept(FooOperation())\n}\n</code></pre>"},{"location":"navmodel/custom/#step-4","title":"Step 4","text":"<p>Add the screen resolver to define which states should be / should not be part of the composition in the end:</p> <pre><code>object FooOnScreenResolver : OnScreenStateResolver&lt;State&gt; {\noverride fun isOnScreen(state: State): Boolean =\nwhen (state) {\nFoo.State.CREATED,\nFoo.State.DESTROYED -&gt; false\nFoo.State.FOO,\nFoo.State.BAR,\nFoo.State.BAZ, -&gt; true\n}\n}\n</code></pre>"},{"location":"navmodel/custom/#step-5","title":"Step 5","text":"<p>Add one or more transition handlers to interpret different states and translate them to Jetpack Compose <code>Modifiers</code>. </p> <pre><code>class FooTransitionHandler&lt;NavTarget&gt;(\nprivate val transitionSpec: TransitionSpec&lt;Foo.State, Float&gt; = { spring() }\n) : ModifierTransitionHandler&lt;NavTarget, Foo.State&gt;() {\n\n// TODO define a Modifier depending on the state.\n//  Here we'll just mutate scaling: \noverride fun createModifier(\nmodifier: Modifier,\ntransition: Transition&lt;Foo.State&gt;,\ndescriptor: TransitionDescriptor&lt;NavTarget, Foo.State&gt;\n): Modifier = modifier.composed {\nval scale = transition.animateFloat(\ntransitionSpec = transitionSpec,\ntargetValueByState = {\nwhen (it) {\nFoo.State.CREATED -&gt; 0f\nFoo.State.FOO -&gt; 0.33f\nFoo.State.BAR -&gt; 0.66f\nFoo.State.BAZ -&gt; 1.0f\nFoo.State.DESTROYED -&gt; 0f\n}\n})\n\nscale(scale.value)\n}\n}\n\n// TODO remember to add:\n@Composable\nfun &lt;NavTarget&gt; rememberFooTransitionHandler(\ntransitionSpec: TransitionSpec&lt;Foo.State, Float&gt; = { spring() }\n): ModifierTransitionHandler&lt;NavTarget, Foo.State&gt; = remember {\nFooTransitionHandler(transitionSpec)\n}\n</code></pre>"},{"location":"navmodel/custom/#test-it","title":"Test it","text":"<p>Add <code>Children</code> to your <code>Node</code>. Pass your NavModel and the transition handler:</p> <pre><code>@Composable\noverride fun View(modifier: Modifier) {\nChildren(\nmodifier = Modifier.fillMaxSize(),\nnavModel = foo,\ntransitionHandler = rememberFooTransitionHandler()\n)\n}\n</code></pre> <p>Somewhere else in your business logic trigger the operations you defined. Make sure they're called on the same <code>foo</code> instance that you pass to the <code>Children</code> composable:</p> <pre><code>foo.someOperation()\n</code></pre> <p>As soon as this is triggered, elements should transition to the <code>BAR</code> state in this example, and you should see them scale up defined by the transition handler.</p>"},{"location":"navmodel/custom/#created-something-cool","title":"Created something cool?","text":"<p>Let us know!</p>"},{"location":"navmodel/promoter/","title":"Promoter carousel","text":"<p>Intended only as an illustration.</p>"},{"location":"navmodel/promoter/#where-can-i-find-this-navmodel","title":"Where can I find this NavModel?","text":"<p>The <code>Promoter</code> NavModel is not currently published, however you can fork the Appyx repository and try it out yourself! If you feel that this functionality should be part of the main library, please let us know.</p>"},{"location":"navmodel/promoter/#states","title":"States","text":"<pre><code>enum class State {\nCREATED, STAGE1, STAGE2, STAGE3, STAGE4, SELECTED, DESTROYED\n}\n</code></pre>"},{"location":"navmodel/promoter/#default-on-screen-resolution","title":"Default on screen resolution","text":"<pre><code>internal object PromoterOnScreenResolver : OnScreenStateResolver&lt;State&gt; {\noverride fun isOnScreen(state: State): Boolean =\nwhen (state) {\nState.DESTROYED -&gt; false\nelse -&gt; true\n}\n}\n</code></pre>"},{"location":"navmodel/promoter/#default-transition-handler","title":"Default transition handler","text":"<p>As elements are promoted to next stages, they're:</p> <ul> <li>animated on a circular path</li> <li>scaled up</li> <li>rotated in the selection / discard stages</li> </ul> <p>You can check <code>PromoterTransitionHandler</code> for implementation details.</p>"},{"location":"navmodel/promoter/#operations","title":"Operations","text":""},{"location":"navmodel/promoter/#add-first","title":"Add first","text":"<p><code>promoter.addFirst(navTarget)</code></p> <p>Adds a new element at the start of the element list with a <code>CREATED</code> state.</p>"},{"location":"navmodel/promoter/#promote-all","title":"Promote all","text":"<p><code>promoter.promoteAll()</code></p> <p>All elements are transitioned to the next state:</p> <ul> <li><code>CREATED</code> -&gt; <code>STAGE1</code></li> <li><code>STAGE1</code> -&gt; <code>STAGE2</code></li> <li><code>STAGE2</code> -&gt; <code>STAGE3</code></li> <li><code>STAGE3</code> -&gt; <code>STAGE4</code></li> <li><code>STAGE4</code> -&gt; <code>SELECTED</code></li> <li><code>SELECTED</code> -&gt; <code>DESTROYED</code></li> </ul>"},{"location":"navmodel/spotlight/","title":"Spotlight","text":"<p>Implements a mechanism analogous to a view pager; has a single active element (\"it's in the spotlight\", hence the name), but unlike the back stack, it does not remove other elements.</p> <p>It's great for flows or tabbed containers.</p>"},{"location":"navmodel/spotlight/#states","title":"States","text":"<pre><code>enum class State {\nINACTIVE_BEFORE, ACTIVE, INACTIVE_AFTER;\n}\n</code></pre>"},{"location":"navmodel/spotlight/#constructing-spotlight","title":"Constructing spotlight","text":"<p>Requires defining items and an active index.</p> <pre><code>class Spotlight&lt;NavTarget : Any&gt;(\nitems: List&lt;NavTarget&gt;,\ninitialActiveIndex: Int = 0,\nsavedStateMap: SavedStateMap?,\n// Optional parameters are omitted\n)\n</code></pre>"},{"location":"navmodel/spotlight/#default-on-screen-resolution","title":"Default on screen resolution","text":"<p>As a default, only the active element is considered on screen.</p> <pre><code>object SpotlightOnScreenResolver : OnScreenStateResolver&lt;Spotlight.State&gt; {\noverride fun isOnScreen(state: Spotlight.State): Boolean =\nwhen (state) {\nSpotlight.State.INACTIVE_BEFORE,\nSpotlight.State.INACTIVE_AFTER -&gt; false\nSpotlight.State.ACTIVE -&gt; true\n}\n}\n</code></pre>"},{"location":"navmodel/spotlight/#default-transition-handlers","title":"Default transition handlers","text":""},{"location":"navmodel/spotlight/#spotlightfader","title":"SpotlightFader","text":"<p><code>rememberSpotlightFader()</code></p> <p>Adds simple cross-fading transitions</p>"},{"location":"navmodel/spotlight/#spotlightslider","title":"SpotlightSlider","text":"<p><code>rememberSpotlightSlider()</code></p> <p>Adds horizontal sliding transitions so that the <code>ACTIVE</code> element is in the center; other states are animated from / to the left or the right edge of the screen, depending on the order of them in the <code>items</code> property.</p>"},{"location":"navmodel/spotlight/#operations","title":"Operations","text":""},{"location":"navmodel/spotlight/#activate","title":"Activate","text":"<p><code>spotlight.activate(navTarget)</code></p> <p>Transitions the element to <code>ACTIVE</code>. Transitions other elements to <code>INACTIVE_BEFORE</code> or <code>INACTIVE_AFTER</code> depending on their relative position to the activated element.</p>"},{"location":"navmodel/spotlight/#next","title":"Next","text":"<p><code>spotlight.next()</code></p> <p>Transitions the currently active element to <code>INACTIVE_BEFORE</code>.  Transitions the element after the currently active one to <code>ACTIVE</code>.</p>"},{"location":"navmodel/spotlight/#previous","title":"Previous","text":"<p><code>spotlight.previous()</code></p> <p>Transitions the currently active element to <code>INACTIVE_AFTER</code>. Transitions the element before the currently active one to <code>ACTIVE</code>.</p>"},{"location":"navmodel/spotlight/#update-elements","title":"Update elements","text":"<p><code>spotlight.updateElements(items, activeIndex)</code></p> <p>Replaces elements held by the spotlight instance with a new list. Transitions new elements to <code>INACTIVE_BEFORE</code>, <code>ACTIVE</code>, or <code>INACTIVE_AFTER</code> depending on their position in the provided list relative to <code>activeIndex</code>.</p>"},{"location":"navmodel/spotlight/#back-press-strategy","title":"Back press strategy","text":"<p>You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own.</p> <pre><code>class Spotlight&lt;NavTarget : Any&gt;(\n/* ... */\nbackPressHandler: BackPressHandlerStrategy&lt;NavTarget, State&gt; = GoToDefault(\ninitialActiveIndex\n)\n/* ... */\n)\n</code></pre>"},{"location":"navmodel/spotlight/#gotodefault","title":"GoToDefault","text":"<p>The default back press handling strategy. Activates the default index.</p>"},{"location":"navmodel/spotlight/#gotoprevious","title":"GoToPrevious","text":"<p>Runs a <code>Previous</code> operation.</p>"},{"location":"navmodel/spotlight/#operation-strategy","title":"Operation strategy","text":"<p>You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own.</p> <pre><code>class Spotlight&lt;NavTarget : Any&gt;(\n/* ... */\noperationStrategy: OperationStrategy&lt;NavTarget, State&gt; = ExecuteImmediately(),    /* ... */\n)\n</code></pre>"},{"location":"navmodel/spotlight/#executeimmediately","title":"ExecuteImmediately","text":"<p>The default strategy. New operations are executed without any questions, regardless of any already running transitions.</p>"},{"location":"navmodel/tiles/","title":"Tiles","text":"<p>Intended only as an illustration, but it should be easy enough to tailor it to your needs if you find it useful.</p>"},{"location":"navmodel/tiles/#where-can-i-find-this-navmodel","title":"Where can I find this NavModel?","text":"<p>The <code>Tiles</code> NavModel is not currently published, however you can fork the Appyx repository and try it out yourself! If you feel that this functionality should be part of the main library, please let us know.</p>"},{"location":"navmodel/tiles/#states","title":"States","text":"<pre><code>enum class State {\nCREATED, STANDARD, SELECTED, DESTROYED\n}\n</code></pre>"},{"location":"navmodel/tiles/#default-on-screen-resolution","title":"Default on screen resolution","text":"<pre><code>internal object TilesOnScreenResolver : OnScreenStateResolver&lt;State&gt; {\noverride fun isOnScreen(state: State): Boolean =\nwhen (state) {\nState.CREATED,\nState.STANDARD,\nState.SELECTED -&gt; true\nState.DESTROYED -&gt; false\n}\n}\n</code></pre>"},{"location":"navmodel/tiles/#default-transition-handler","title":"Default transition handler","text":"<p>Selection translates to scaling. Destroying makes elements fly off the screen with rotation and downscaling.</p>"},{"location":"navmodel/tiles/#operations","title":"Operations","text":""},{"location":"navmodel/tiles/#add","title":"Add","text":"<p><code>tiles.add(navTarget)</code></p> <p>Adds a new element to the NavModel immediately transitioning from <code>CREATED</code> -&gt; <code>STANDARD</code>.</p>"},{"location":"navmodel/tiles/#destroy","title":"Destroy","text":"<p><code>tiles.destroy(navTarget)</code></p> <p>Transitions a given element to <code>DESTROYED</code>.</p>"},{"location":"navmodel/tiles/#select","title":"Select","text":"<p><code>tiles.select(navTarget)</code></p> <p>Transitions a given element <code>STANDARD</code> -&gt; <code>SELECTED</code>.</p>"},{"location":"navmodel/tiles/#deselect","title":"Deselect","text":"<p><code>tiles.deselect(navTarget)</code></p> <p>Transitions a given element <code>SELECTED</code> -&gt; <code>STANDARD</code>.</p>"},{"location":"navmodel/tiles/#deselect-all","title":"Deselect all","text":"<p><code>tiles.deselectAll()</code></p> <p>Transitions all elements <code>SELECTED</code> -&gt; <code>STANDARD</code>.</p>"},{"location":"navmodel/tiles/#remove-selected","title":"Remove selected","text":"<p><code>tiles.removeSelected()</code></p> <p>Transitions all elements that have <code>SELECTED</code> state to <code>DESTROYED</code>.</p>"},{"location":"releases/changelog/","title":"Changelog","text":""},{"location":"releases/changelog/#pending-changes","title":"Pending changes","text":"<p>\u2013</p>"},{"location":"releases/changelog/#102","title":"1.0.2","text":"<ul> <li>#287 \u2013 Added: Introduced a new <code>rememberCombinedHandler</code> implementation that takes an immutable list to avoid non-skippable compositions. The previous implementation is now deprecated.</li> <li>#287 \u2013 Added: <code>ImmutableList</code> has been added to avoid non-skippable compositions. </li> <li>#289 \u2013 Added: Introduced <code>interop-rx3</code> for RxJava 3 support. This has identical functionality to <code>interop-rx2</code>.</li> <li>#298 \u2013 Updated: ChildView documentation. <code>TransitionDescriptor</code> generics has been renamed to <code>NavTarget</code> and <code>State</code></li> <li>#307 - Added: <code>Spotlight.current()</code> method to observe currently active <code>NavTarget</code>.</li> <li>#314 \u2013 Fixed: Lifecycle is properly destroyed for suspended nodes.</li> </ul> 10 Jan 2023"},{"location":"releases/changelog/#101","title":"1.0.1","text":"<ul> <li>#268 \u2013 Fixed: <code>PermanentChild</code> now does not crash in UI tests with <code>ComposeTestRule</code>.</li> <li>#276 \u2013 Fixed: Back press handlers order is fixed for RIBs-Appyx integration.</li> <li>#272 \u2013 Changed: <code>attachWorkflow</code> renamed to <code>attachChild</code>. <code>executeWorkflow</code> renamed to <code>executeAction</code>.</li> <li>#272 \u2013 Added: <code>NodeReadyObserver</code> plugin to observe when the <code>Node</code> is ready</li> </ul> 22 Nov 2022"},{"location":"releases/changelog/#100","title":"1.0.0","text":"<ul> <li>#247 \u2013 Added: Added <code>EmptyNavModel</code> to core for cases in which a <code>ParentNode</code> only uses <code>PermanentChild</code>. The <code>DummyNavModel</code> test class is deprecated.</li> <li>#250 \u2013 Updated: Jetpack Compose to 1.3.0</li> </ul> 31 Oct 2022"},{"location":"releases/changelog/#100-rc02","title":"1.0.0-rc02","text":"<ul> <li>#231 \u2013 Fixed: Changing transition handler at runtime does not redraw children</li> <li>#239 \u2013 Fixed: Fixed an issue with desynchronisation between NavModel and children's restoration process</li> <li>#218 \u2013 Updated: <code>androidx.core:core-ktx</code> to 1.9.0.</li> </ul> 21 Oct 2022"},{"location":"releases/changelog/#100-rc01","title":"1.0.0-rc01","text":"<ul> <li>#214 \u2013 Breaking change: <code>AppyxViewTestRule</code> stops supporting automatic launching activity. Activities should be started explicitly in tests.</li> <li>#197 \u2013 Breaking change: <code>ParentNodeView</code> does not implement plugin anymore. <code>Node</code> instance is retrieved via <code>LocalComposition</code>. <code>AppyxParentViewTestRule</code> and <code>AbstractParentNodeView</code> have been removed. </li> <li>#196 \u2013 Breaking change: <code>InteropBuilder</code> now should be supplied with Appyx <code>IntegrationPointProvider</code> to attach it at the same time Appyx Node is created.</li> <li>#185 \u2013 Breaking change: <code>Activity</code> must implement <code>IntegrationPointProvider</code> and create <code>IntegrationPoint</code> manually. Weak references usage has been removed.</li> <li>#173 \u2013 Breaking change: <code>ActivityStarter</code> and <code>PermissionRequester</code> now exposes coroutine based API instead of <code>minimal.reactive</code>.</li> <li>#200 \u2013 Breaking change: Reordered the parameters for <code>ParentNode&lt;NavTarget&gt;.Child</code> and <code>fun &lt;N : Node&gt; NodeHost</code> to meet Compose guidelines.</li> <li>#43 \u2013 Updated: Jetpack Compose to <code>1.2.1</code> and Kotlin to <code>1.7.10</code>.</li> <li>#168 \u2013 Updated: Kotlin coroutines to <code>1.6.4</code>.</li> <li>#171 \u2013 Updated: RIBs to <code>0.36.1</code>.</li> <li>#212 \u2013 Updated: <code>Node</code> parent property is now public instead of private.</li> <li>#174 \u2013 Fixed: <code>IntegrationPointExample</code> does not work with \"do not keep activities\"</li> <li>#180 \u2013 Added: Ensure that <code>super.onSaveInstanceState()</code> was called to restore Node's state correctly</li> </ul> 13 Oct 2022"},{"location":"releases/changelog/#10-alpha09","title":"1.0-alpha09","text":"<ul> <li>#151 - Breaking change: Renamed <code>Routing</code> to <code>NavTarget</code>. All related namings are affected (<code>RoutingElement</code>, <code>RoutingKey</code>, etc.)</li> <li>#158 - Breaking change: Renamed <code>TransitionState</code> to <code>State</code> in all NavModel impls. Renamed <code>STASHED_IN_BACK_STACK</code> to <code>STASHED</code>.</li> <li>#146 - Breaking change: Removed <code>FragmentIntegrationPoint</code>. Clients should use <code>ActivityIntegrationPoint.getIntegrationPoint(context: Context)</code> to get integration point from Fragment </li> <li>#160 - Breaking change: Renamed <code>navmodel-addons</code> to <code>navmodel-samples</code> and stopped publishing the binary. If you feel we should add any of the samples to the main codebase, please let us know! </li> <li>#138 - Fixed: <code>androidx.appcompat:appcompat</code> from is exposed via <code>api</code> within <code>com.bumble.appyx:core</code>. This prevents potential compilation bugs.</li> <li>#143 - Fixed: Correctly exposed transitive dependencies that are part of the libraries ABI</li> <li>#162 - Fixed: <code>NodeTestHelper</code>'s <code>moveTo</code> function can now move to <code>Lifecycle.State.DESTROYED</code>. The node itself has safeguards to prevent moving from destroyed state, and moving to destroyed is a valid test case.</li> <li>#145 - Updated: <code>SpotlightSlider</code> now uses offset modifier with lambda</li> <li>#159 - Added: <code>NodeHost</code> now takes modifier parameter to decorate the view of a root node</li> <li>#162 - Added: <code>disposeOnDestroyPlugin</code> extension has been added to interop-rx2. This will allow Rx2 code to be easily disposed when the node it belongs to is destroyed. </li> <li>#161 - Added: Operations helpers</li> </ul> 22 Sep 2022"},{"location":"releases/changelog/#10-alpha08","title":"1.0-alpha08","text":"<ul> <li>#140 - Breaking change: Added <code>testing-ui-activity</code> module to avoid needing to add <code>testing-ui</code> as a debug implementation as part of instrumentation testing. See the linked issue for more details</li> <li>#139 - Fixed: <code>IntegrationPoint</code> memory leak created by <code>ActivityIntegrationPoint</code></li> </ul> 12 Sep 2022"},{"location":"releases/changelog/#10-alpha07","title":"1.0-alpha07","text":"<ul> <li>#122 - Breaking change: <code>ChildEntry.ChildMode</code> is removed, now nodes are always created when a nav model changes (previously default behaviour)</li> <li>#99 \u2013 Breaking change: Removed <code>IntegrationPointAppyxProvider</code> and made <code>ActivityIntegrationPoint</code>'s constructor private. Use <code>ActivityIntegrationPoint.createIntegrationPoint</code>. This uses a weak reference to keep track of the integration points, and will not introduce memory leaks.</li> <li>#122 - Added: New <code>ChildEntry.KeepMode</code> that allows to destroy nodes that are currently not visible on the screen</li> <li>#132 - Added: New <code>NodeComponentActivity</code> to extend when wanting to work with <code>ComponentActivity</code> as your base activity, eg when migrating from a project built from the Jetpack Compose template</li> <li>#119 - Fixed: Lifecycle observers are invoked in incorrect order (child before parent)</li> <li>#62 - Fixed: Node is marked with stable annotation making some of the composable functions skippable</li> <li>#129 - Updated: Removed sealed interface from operations to allow client to define their own</li> <li>#133 - Updated: <code>NodeView</code> interface and <code>ParentNode</code> marked as stable improving amount of skippable composables</li> </ul> 9 Sep 2022"},{"location":"releases/changelog/#10-alpha06","title":"1.0-alpha06","text":"<ul> <li>#96 \u2013 Breaking change: Removed <code>InteractorTestHelper</code>. Please use Node tests instead of Interactor tests.</li> <li>#99 \u2013 Breaking change: Modified package of <code>NodeConnector</code> and <code>Connectable</code></li> <li>#99 \u2013 Added: Source.rx2() to convert Source to io.reactivex.Observable <li>#107 \u2013 Fixed: Back press handlers are not properly registered on lifecycle events</li> 26 Aug 2022"},{"location":"releases/changelog/#10-alpha05","title":"1.0-alpha05","text":"<ul> <li>#83 \u2013 Breaking change: <code>RoutingSource</code> renamed to <code>NavModel</code>. All subclasses, fields, package names, etc., any mentions of the word follow suit.</li> <li>#91 \u2013 Fixed: Spotlight next and previous operations crash fix </li> </ul> 19 Aug 2022"},{"location":"releases/changelog/#10-alpha04","title":"1.0-alpha04","text":"<ul> <li>#39 \u2013 Added: Workflows implementation to support deeplinks</li> <li>#32 \u2013 Added: <code>BackPressHandler</code> plugin that allows to control back press behaviour via <code>androidx.activity.OnBackPressedCallback</code></li> <li>#59 \u2013 Added: interface for <code>ParentNodeView&lt;&gt;</code></li> <li>#32 \u2013 Added: Jetpack Compose Navigation code sample</li> <li>#81 \u2013 Added: Support integration point for multiple roots</li> <li>#65 \u2013 Added: <code>InteropBuilderStub</code> and <code>InteropSimpleBuilderStub</code> testing util classes</li> <li>#47 \u2013 Updated: The <code>customisations</code> module is now pure Java/Kotlin.</li> <li>#85 \u2013 Updated: Improved <code>InteropView</code> error messaging when <code>Activity</code> does not implement <code>IntegrationPointAppyxProvider</code></li> <li>#88 \u2013 Updated: Moved <code>TestUpNavigationHandler</code> to <code>testing-unit-common</code></li> </ul> 18 Aug 2022"},{"location":"releases/changelog/#10-alpha03","title":"1.0-alpha03","text":"<ul> <li>#38 \u2013 Added: JUnit5 support</li> </ul> 2 Aug 2022"},{"location":"releases/changelog/#10-alpha02","title":"1.0-alpha02","text":"<ul> <li>#19 \u2013 Fixed: Do not allow setting <code>Node.integrationPoint</code> on non-root nodes</li> <li>#23 \u2013 Fixed: Integration point attached twice crash when using live literals</li> <li>#14 \u2013 Fixed: Transition interruptions bug</li> <li>#23 \u2013 Added: Unit test support</li> <li>#26 \u2013 Added: Publish snapshot versions</li> <li>#9 \u2013 Migrated: app-tree-utils into this repository</li> </ul> 19 Jul 2022"},{"location":"releases/changelog/#10-alpha01","title":"1.0-alpha01","text":"<ul> <li>Initial release</li> </ul> 4 Jul 2022"},{"location":"releases/downloads/","title":"Downloads","text":""},{"location":"releases/downloads/#latest-version","title":"Latest version","text":""},{"location":"releases/downloads/#repository","title":"Repository","text":"<pre><code>repositories {\nmavenCentral()\n}\n</code></pre>"},{"location":"releases/downloads/#core-dependencies","title":"Core dependencies","text":"<pre><code>dependencies {\n// Core\nimplementation \"com.bumble.appyx:core:$version\"\n\n// Test rules and utility classes for testing on Android\ndebugImplementation \"com.bumble.appyx:testing-ui-activity:$version\"\nandroidTestImplementation \"com.bumble.appyx:testing-ui:$version\"\n\n// Utility classes for unit testing\ntestImplementation \"com.bumble.appyx:testing-unit-common:$version\"\n\n// Test rules and utility classes for unit testing using JUnit4\ntestImplementation \"com.bumble.appyx:testing-junit4:$version\"\n\n// Test extensions and utility classes for unit testing using JUnit5\ntestImplementation \"com.bumble.appyx:testing-junit5:$version\"\n}\n</code></pre>"},{"location":"releases/downloads/#interop-with-other-libraries","title":"Interop with other libraries","text":"<pre><code>dependencies {\n// Optional support for RxJava 2/3\nimplementation \"com.bumble.appyx:interop-rx2:$version\"\nimplementation \"com.bumble.appyx:interop-rx3:$version\"\n\n// Optional interoperability layer between Appyx and badoo/RIBs\n// You have to add https://jitpack.io repository to use it because badoo/RIBs is hosted there\nimplementation \"com.bumble.appyx:interop-ribs:$version\"\n\n}\n</code></pre>"},{"location":"releases/downloads/#snapshot","title":"Snapshot","text":"<p>Snapshot version is available for all modules, use the provided repository url and <code>1-SNAPSHOT</code> version.</p> <pre><code>repositories {\nmaven { url = 'https://s01.oss.sonatype.org/content/repositories/snapshots/' }\n}\n\ndependencies {\nimplementation \"com.bumble.appyx:core:v1-SNAPSHOT\"\n}\n</code></pre>"},{"location":"ui/children-view/","title":"Adding children to the view","text":"<p>Navigation models define only the abstract model, not how that model will look on the screen. This section describes different ways of adding children (navigation targets) to the composition.</p> <p>All the below mentioned composables should be added to the <code>View</code> of the parent node.</p>"},{"location":"ui/children-view/#children","title":"Children","text":"<p>Renders all visible children of a NavModel. This is the simplest and most common case.</p> <pre><code>@Composable\noverride fun View(modifier: Modifier) {\nChildren(\nmodifier = Modifier, // optional\nnavModel = TODO(),\ntransitionHandler = TODO() // optional\n)\n}\n</code></pre> <p>When rendering children you can have access to <code>TransitionDescriptor</code> which provides the following information:</p> <pre><code>@Immutable\ndata class TransitionDescriptor&lt;NavTarget, out State&gt;(\nval params: TransitionParams,\nval operation: Operation&lt;NavTarget, out State&gt;,\nval element: NavTarget,\nval fromState: State,\nval toState: State\n)\n</code></pre> <p>Additionally, you can supply custom modifier to a child <code>Node</code>. In this example, we're supplying different <code>Modifier</code> to a child <code>Node</code> depending on the <code>NavTarget</code>: </p> <pre><code>@Composable\noverride fun View(modifier: Modifier) {\nChildren(\nmodifier = Modifier, // optional\nnavModel = TODO(),\ntransitionHandler = TODO() // optional\n) {\nchildren&lt;NavTarget&gt; { child, descriptor -&gt;\nchild(\nmodifier = Modifier\n.background(\ncolor = getBackgroundColor(descriptor.element)\n)\n)\n}\n}\n}\n</code></pre>"},{"location":"ui/children-view/#child","title":"Child","text":"<p>Renders a single child associated to a <code>NavElement</code>. Useful if you want to define different child placements in the layout individually. </p> <pre><code>@Composable\noverride fun View(modifier: Modifier) {\nChild(\nnavElement = element,\ntransitionHandler = TODO()\n) { child, _ -&gt;\n// TODO wrap in your own composables\nchild()\n}\n}\n</code></pre>"},{"location":"ui/children-view/#lazy-lists-grids","title":"Lazy lists / grids","text":"<pre><code>@Composable\noverride fun View(modifier: Modifier) {\n// TODO grab all visible children from the navModel manually\nval children by navModel.visibleChildrenAsState()\nGridExample(children)\n}\n\n@Composable\nprivate fun GridExample(elements: List&lt;NavElement&lt;NavTarget, out Any?&gt;&gt;) {\nLazyVerticalGrid(\ncolumns = Fixed(2),\nmodifier = Modifier.fillMaxSize(),\ncontentPadding = PaddingValues(horizontal = 16.dp),\n) {\nitems(elements) { element -&gt;\n// TODO use Child composable to render them individually inside the list / grid\nChild(navElement = element)\n}\n}\n}\n</code></pre>"},{"location":"ui/transitions/","title":"Transitions","text":"<p>You can have arbitrary visualisations and transitions for any NavModel. For example, all of these are different representations of the same Back stack:</p> <p> </p> <p>Below you can find the different options how to visualise <code>NavModel</code> state changes. </p>"},{"location":"ui/transitions/#no-transitions","title":"No transitions","text":"<p>Using the provided Child-related composables you'll see no transitions as a default \u2013 UI changes resulting from the NavModel's state update will be rendered instantly. </p>"},{"location":"ui/transitions/#jetpack-compose-default-animations","title":"Jetpack Compose default animations","text":"<p>You can use standard Compose animations for embedded child <code>Nodes</code> in the view, e.g. <code>AnimatedVisibility</code>:</p> <pre><code>var visibility by remember { mutableStateOf(true) }\n\nChild(navElement) { child, _ -&gt;\nAnimatedVisibility(visible = visibility) {\nchild()\n}\n}\n</code></pre>"},{"location":"ui/transitions/#appyx-transition-handlers","title":"Appyx transition handlers","text":"<p>All the child composables provided by Appyx accept an optional <code>transitionHandler</code> argument too:</p> <ul> <li>You can use the provided ones as they're a one-liner to add \u2013 you can check the individual NavModels for the ones they come shipped with.</li> <li>You can also implement your own.</li> </ul> <p>The benefit of using transition handlers is you can represent any custom state of elements defined by your NavModel with Compose <code>Modifiers</code>.</p> <p>The example below is taken from custom navigation models. It matches custom transition states to different scaling values, and returns a <code>scale</code> <code>Modifier</code>. </p> <pre><code>class FooTransitionHandler&lt;T&gt;(\nprivate val transitionSpec: TransitionSpec&lt;Foo.State, Float&gt; = { spring() }\n) : ModifierTransitionHandler&lt;T, Foo.State&gt;() {\n\n// TODO define a Modifier depending on the state.\n//  Here we'll just mutate scaling: \noverride fun createModifier(\nmodifier: Modifier,\ntransition: Transition&lt;Foo.State&gt;,\ndescriptor: TransitionDescriptor&lt;T, Foo.State&gt;\n): Modifier = modifier.composed {\nval scale = transition.animateFloat(\ntransitionSpec = transitionSpec,\ntargetValueByState = {\nwhen (it) {\nFoo.State.CREATED -&gt; 0f\nFoo.State.FOO -&gt; 0.33f\nFoo.State.BAR -&gt; 0.66f\nFoo.State.BAZ -&gt; 1.0f\nFoo.State.DESTROYED -&gt; 0f\n}\n})\n\nscale(scale.value)\n}\n}\n\n// TODO remember to add:\n@Composable\nfun &lt;T&gt; rememberFooTransitionHandler(\ntransitionSpec: TransitionSpec&lt;Foo.State, Float&gt; = { spring() }\n): ModifierTransitionHandler&lt;T, Foo.State&gt; = remember {\nFooTransitionHandler(transitionSpec)\n}\n</code></pre>"},{"location":"ui/transitions/#more-info","title":"More info","text":"<ol> <li>You can find more complex examples in the implementations of other NavModels, such as the Promoter carousel</li> <li>You can find Codelabs tutorials that help you master custom transitions</li> <li>You can find Coding challenges related to custom transitions </li> </ol>"}]}